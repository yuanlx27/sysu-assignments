#import "@local/sysu-templates:0.3.0" as sysu
#import "@preview/cetz:0.4.2" as cetz

#import sysu.zuoye: *

#show: zuoye.with(
  title: "第四章作业",
  subtitle: "算法设计与分析",
  student: (name: "元朗曦", id: "23336294"),
)

= 4.5

有 $n$ 个文件需要存储在磁盘上，第 $i$ 个文件需要 $p_i$ 个字节的存储空间，$i = 1, 2, dots, n$．磁盘的总容量是 $C$，且

$
  sum_(i = 1)^(n) p_i > C.
$

+ 如果要求存入的文件个数达到最多，那么应选用哪种算法设计技术？简述算法设计思想，证明算法的正确性，并估计算法最坏情况下的时间复杂度．

+ 如果要求磁盘的剩余空间达到最小，那么应选用哪种算法设计技术？简述算法设计思想，并估计算法最坏情况下的时间复杂度．

#solution[
  + 应使用*贪心算法*．将文件从小到大排序，依次选择最小的文件存入磁盘，直到无法再存入下一个文件为止．

    *正确性证明：*假设存在一种存储方案 $S$，其存入的文件个数多于贪心算法得到的方案 $G$．设 $G$ 存入了 $k$ 个文件，$S$ 存入了 $k + 1$ 个文件．由于贪心算法每次选择最小的文件，$G$ 存入的前 $k$ 个文件的总大小小于等于 $S$ 存入的任意 $k$ 个文件的总大小．因此，$S$ 存入的第 $k + 1$ 个文件必然无法存入磁盘，这与假设矛盾．

    时间复杂度为 $O(n log n)$．

  + 应使用*动态规划算法*．这是一个 0-1 背包问题的变体．时间复杂度为 $O(n C)$．
]

= 4.8

有一个考察队到野外进行考察，在考察路线上有 $n$ 个地点可以作为宿营地．已知宿营地到出发点的距离依次为 $x_1, x_2, dots, x_n$，且满足 $x_1 < x_2 < dots < x_n$．每天他们只能前进 30km，而任意两个相邻的宿营地之间的距离都不超过 30km．在每个宿营地只住 1 天．他们希望找到一个行动计划，使得总的宿营天数达到最少．设计一个算法求解这个问题．给出算法的主要步骤，证明算法是正确的，并估计算法的时间复杂度．

#solution[
  使用*贪心算法*．从出发点开始，每天选择距离当前宿营地最远且不超过 30km 的下一个宿营地作为新的宿营地，直到到达终点．

  *正确性证明：*假设存在一种行动计划 $S$，其总的宿营天数少于贪心算法得到的计划 $G$．设 $G$ 的总宿营天数为 $k$，$S$ 的总宿营天数为 $k - 1$．由于贪心算法每次选择最远的宿营地，$G$ 在前 $k - 1$ 天内覆盖的距离必然大于等于 $S$ 在前 $k - 1$ 天内覆盖的距离．因此，$S$ 必然无法到达最后一个露营地，与假设矛盾．

  时间复杂度为 $O(n)$，因为每个宿营地最多被访问一次．
]

= 4.12

设字符集 $S$，其中 8 个字符 $A, B, C, D, E, F, G, H$ 的频率分别是 $f_1, f_2, dots, f_8$，且 $100 times f_i$ 是第 $i$ 个 Fibonacci 数的值，$i = 1, 2, dots, 8$．

+ 给出这 8 个字符的 Huffman 树和编码．

+ 如果有 $n$ 个字符，其频率恰好对应前 $n$ 个 Fibonacci 数，那么对应的 Huffman 树是什么结构，证明你的结论．

#solution[
  + 由 Fibonacci 数列的性质易知，Huffman 树如下所示：

    #cetz.canvas({
      import cetz.draw: *
      import cetz.tree: *

      set-style(content: (padding: 0.2))
      tree((
        $*$,
        $H$,
        (
          $*$,
          $G$,
          (
            $dots.c$,
            (
              $*$,
              $A$,
              $B$,
            ),
          ),
        ),
      ))
    })

    Huffman 编码如下：

    ```
    H: 0
    G: 10
    F: 110
    E: 1110
    D: 11110
    C: 111110
    A: 1111110
    B: 1111111
    ```

  + 链式结构．Fibonacci 数列的性质

    $
      f_i < sum_(j = 1)^(i - 1) f_j < f_(i + 1)
    $

    保证了这一结构．
]

= 4.13

设有作业集合 $J = {1, 2, dots, n}$，每项作业的加工时间都是 1．所有作业的截止时间是 $D$．若作业 $i$ 在 $D$ 之后完成，则称为被延误的作业，并需要赔偿罚款 $m(i)$．这里的 $D$ 和 $m(i) (i = 1, 2, dots, n)$ 都是正整数，且 $n$ 项 $m(i)$ 彼此不等．$J$ 的一个调度是函数 $f: j -> NN$，其中，$NN$ 为自然数集合，$f(i)$ 表示作业 $i$ 开始加工的时间，$i=1, 2, dots, n$．设计一个算法求出使得总罚款最少的调度，证明算法的正确性，并给出最坏情况下的时间复杂度．

#solution[
  使用*贪心算法*．将作业按罚款从大到小排序，然后依次加工每项作业．

  *正确性证明：*由题意可知，被延误的作业的数量固定为 $k = max{n - D, 0}$。而我们的算法中被延误的作业是罚款最低的 $k$ 项作业，因此总罚款必然是所有方案中最少的．

  时间复杂度为 $O(n log n)$．
]
