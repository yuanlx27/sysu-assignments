#import "@local/sysu-templates:0.2.0": report

#show: report.with(
  title: "实验十二：数据库并发控制",
  subtitle: "数据库系统实验报告",
  student: (name: "元朗曦", id: "23336294"),
  institude: "计算机学院",
  major: "计算机科学与技术",
  class: "计八",
)

= 实验目的

了解并掌握数据库的保护措施——并发控制机制，重点以 MySQL 为平台加以操作实践，要求认识典型的并发问题并掌握解决方法。

= 实验环境

+ 操作系统：Arch Linux 6.17.9

+ 数据库管理系统：MariaDB 12.1.2 in Podman 5.7.1

= 实验内容

重复实验教材第 12 章表 12-5、表 12-6 及表 12-11 中的实验，每个实验结果给出屏幕截图，并分析为何出现这种现象。

#figure(
  caption: [表 12-5 实验结果],
  image("assets/images/20260110-122511.png"),
)

由于我们将隔离级别设置为 `READ UNCOMMITTED`，因此事务 $T_2$ 可以读取到事务 $T_1$ 未提交的数据，从而出现了脏读现象。

#figure(
  caption: [表 12-6 实验结果],
  image("assets/images/20260110-124234.png"),
)

在这个例子中，我们对查询添加了共享锁，事务 $T_2$ 在读取数据时会等待事务 $T_1$ 提交后才能继续执行，从而避免了脏读现象的发生。

#figure(
  caption: [表 12-11 实验结果],
  image("assets/images/20260110-131123.png"),
)

这是一个涉及父子表关系的死锁案例，两个会话以相反的顺序访问 `student` 和 `course` 表。在执行过程中，InnoDB 检测到死锁并选择回滚其中一个事务（$T_2$）以解除死锁，从而保证数据库的一致性。

= 实验总结

本次实验通过三个典型案例深入理解了数据库并发控制机制及其在 MySQL 中的实现：

- 实验一展示了在 `READ UNCOMMITTED` 隔离级别下的脏读问题。由于该隔离级别允许事务读取未提交的数据，事务二能够看到事务一尚未提交的修改结果，这可能导致数据不一致。

- 实验二通过引入共享锁解决了脏读问题。当事务对数据加共享锁后，其他事务的排他锁请求将被阻塞，必须等待当前事务提交或回滚后才能继续，从而保证了读取数据的一致性。

- 实验三演示了经典的死锁场景。两个事务以相反顺序访问同一组资源（`student` 表和 `course` 表），形成循环等待。InnoDB 的死锁检测机制通过等待图算法识别死锁，并自动选择回滚其中一个事务来解除僵局。

通过本次实验，我们认识到：

+ 合理选择事务隔离级别对避免并发问题至关重要；

+ 适当使用锁机制可以有效控制并发访问；

+ 统一的资源访问顺序是预防死锁的关键；
